import tkinter as tk
import time
import math
from tkinter import messagebox, ttk
from collections import deque
import heapq
import random
from collections import deque
import threading

# Thu·∫≠t to√°n BFS (Breadth First Search)
def bfs(start, goal):
    print("\nüîç ƒêang ch·∫°y BFS...")
    queue = deque([(start, [])])
    visited = set()
    visited.add(tuple(map(tuple, start)))

    while queue:
        state, path = queue.popleft()
        if state == goal:
            return path
        zero_pos = [(i, row.index(0)) for i, row in enumerate(state) if 0 in row][0]
        moves = get_valid_moves(zero_pos)

        for move in moves:
            new_state = swap_tiles([row[:] for row in state], zero_pos, move)
            state_tuple = tuple(map(tuple, new_state))
            if state_tuple not in visited:
                visited.add(state_tuple)
                queue.append((new_state, path + [new_state]))
    return None


# Thu·∫≠t to√°n DFS (Depth First Search)
def dfs(start, goal, max_depth=50):
    print("\nüîç ƒêang ch·∫°y DFS...")
    for depth in range(max_depth):
        result = limited_dfs(start, goal, [], depth)
        if result is not None:
            return result
    return None

def limited_dfs(state, goal, path, depth):
    if state == goal:
        return path
    if depth == 0:
        return None

    zero_pos = [(i, row.index(0)) for i, row in enumerate(state) if 0 in row][0]
    moves = get_valid_moves(zero_pos)

    for move in moves:
        new_state = swap_tiles([row[:] for row in state], zero_pos, move)
        if new_state not in path:
            new_path = path + [new_state]
            result = limited_dfs(new_state, goal, new_path, depth - 1)
            if result is not None:
                return result
    return None

# Thu·∫≠t to√°n IDS (Iterative Deepening Search)
def ids(start, goal, max_depth=50):
    print("\nüîç ƒêang ch·∫°y IDS...")
    for depth in range(max_depth):
        visited = set()
        result = limited_dfs_ids(start, goal, [], depth, visited)
        if result is not None:
            return result
    return None

def limited_dfs_ids(state, goal, path, depth, visited):
    if state == goal:
        return path
    if depth == 0:
        return None

    state_tuple = tuple(map(tuple, state))  # Chuy·ªÉn state th√†nh d·∫°ng hashable ƒë·ªÉ l∆∞u v√†o set
    if state_tuple in visited:
        return None
    visited.add(state_tuple)

    zero_pos = [(i, row.index(0)) for i, row in enumerate(state) if 0 in row][0]
    moves = get_valid_moves(zero_pos)

    for move in moves:
        new_state = swap_tiles([row[:] for row in state], zero_pos, move)
        if new_state not in path:
            new_path = path + [new_state]
            result = limited_dfs_ids(new_state, goal, new_path, depth - 1, visited)
            if result is not None:
                return result
    return None

# Thu·∫≠t to√°n UCS (Uniform Cost Search)
def ucs(start, goal):
    print("\nüîç ƒêang ch·∫°y UCS...")
    priority_queue = [(0, start, [])]  # (Chi ph√≠, tr·∫°ng th√°i, ƒë∆∞·ªùng ƒëi)
    visited = set()
    visited.add(tuple(map(tuple, start)))

    while priority_queue:
        cost, state, path = heapq.heappop(priority_queue)
        if state == goal:
            return path
        zero_pos = [(i, row.index(0)) for i, row in enumerate(state) if 0 in row][0]
        moves = get_valid_moves(zero_pos)

        for move in moves:
            new_state = swap_tiles([row[:] for row in state], zero_pos, move)
            state_tuple = tuple(map(tuple, new_state))
            if state_tuple not in visited:
                visited.add(state_tuple)
                heapq.heappush(priority_queue, (cost + 1, new_state, path + [new_state]))
    return None

# Thu·∫≠t to√°n Greedy Best-First Search
def greedy(start, goal):
    print("\nüîç ƒêang ch·∫°y Greedy...")
    priority_queue = [(manhattan_distance(start, goal), start, [])]
    visited = set()
    visited.add(tuple(map(tuple, start)))

    while priority_queue:
        _, state, path = heapq.heappop(priority_queue)
        if state == goal:
            return path
        zero_pos = [(i, row.index(0)) for i, row in enumerate(state) if 0 in row][0]
        moves = get_valid_moves(zero_pos)

        for move in moves:
            new_state = swap_tiles([row[:] for row in state], zero_pos, move)
            state_tuple = tuple(map(tuple, new_state))
            if state_tuple not in visited:
                visited.add(state_tuple)
                heapq.heappush(priority_queue, (manhattan_distance(new_state, goal), new_state, path + [new_state]))
    return None

# Thu·∫≠t to√°n A* Search
def a_star(start, goal):
    print("\nüîç ƒêang ch·∫°y A*...")
    priority_queue = [(manhattan_distance(start, goal), 0, start, [])]  # (h(n) + g(n), g(n), state, path)
    visited = set()
    visited.add(tuple(map(tuple, start)))

    while priority_queue:
        _, cost, state, path = heapq.heappop(priority_queue)
        if state == goal:
            return path
        zero_pos = [(i, row.index(0)) for i, row in enumerate(state) if 0 in row][0]
        moves = get_valid_moves(zero_pos)

        for move in moves:
            new_state = swap_tiles([row[:] for row in state], zero_pos, move)
            state_tuple = tuple(map(tuple, new_state))
            if state_tuple not in visited:
                visited.add(state_tuple)
                new_cost = cost + 1
                priority = new_cost + manhattan_distance(new_state, goal)
                heapq.heappush(priority_queue, (priority, new_cost, new_state, path + [new_state]))
    return None

# Thu·∫≠t to√°n IDA* (Iterative Deepening A*)
def ida_star(start, goal):
    """ Gi·∫£i b√†i to√°n 8-Puzzle b·∫±ng thu·∫≠t to√°n IDA* """
    print("\nüîµ ƒêang ch·∫°y IDA*...")

    def search(path, g, bound):
        state = path[-1]
        f = g + manhattan_distance(state, goal)
        if f > bound:
            return f
        if state == goal:
            return path

        min_cost = float('inf')
        zero_pos = [(i, row.index(0)) for i, row in enumerate(state) if 0 in row][0]
        moves = get_valid_moves(zero_pos)

        for move in moves:
            new_state = swap_tiles([row[:] for row in state], zero_pos, move)
            if new_state not in path:  # Tr√°nh l·∫∑p l·∫°i tr·∫°ng th√°i ƒë√£ ƒëi qua
                path.append(new_state)
                result = search(path, g + 1, bound)
                if isinstance(result, list):  # T√¨m th·∫•y l·ªùi gi·∫£i
                    return result
                min_cost = min(min_cost, result)
                path.pop()
        return min_cost

    bound = manhattan_distance(start, goal)
    path = [start]

    while True:
        result = search(path, 0, bound)
        if isinstance(result, list):  # N·∫øu t√¨m th·∫•y l·ªùi gi·∫£i
            return result
        if result == float('inf'):
            return None  # Kh√¥ng t√¨m th·∫•y l·ªùi gi·∫£i
        bound = result  # C·∫≠p nh·∫≠t gi·ªõi h·∫°n chi ph√≠ cho v√≤ng l·∫∑p ti·∫øp theo


# Thu·∫≠t to√°n Simple Hill Climbing
def simple_hill_climbing(start, goal):
    print("\nüîç ƒêang ch·∫°y Simple Hill Climbing...")
    current_state = start
    path = [current_state]
    visited = set()
    visited.add(tuple(map(tuple, current_state)))

    while current_state != goal:
        zero_pos = [(i, row.index(0)) for i, row in enumerate(current_state) if 0 in row][0]
        moves = get_valid_moves(zero_pos)

        # T√¨m tr·∫°ng th√°i con t·ªët nh·∫•t (c√≥ kho·∫£ng c√°ch Manhattan nh·ªè nh·∫•t)
        best_state = None
        best_heuristic = float('inf')

        for move in moves:
            new_state = swap_tiles([row[:] for row in current_state], zero_pos, move)
            state_tuple = tuple(map(tuple, new_state))
            if state_tuple not in visited:
                heuristic = manhattan_distance(new_state, goal)
                if heuristic < best_heuristic:
                    best_heuristic = heuristic
                    best_state = new_state

        # N·∫øu kh√¥ng t√¨m th·∫•y tr·∫°ng th√°i con n√†o t·ªët h∆°n, d·ª´ng l·∫°i
        if best_state is None:
            print("‚ùå ƒê√£ d·ª´ng l·∫°i t·∫°i c·ª±c ƒë·∫°i c·ª•c b·ªô!")
            return path

        # Chuy·ªÉn sang tr·∫°ng th√°i t·ªët nh·∫•t
        current_state = best_state
        visited.add(tuple(map(tuple, current_state)))
        path.append(current_state)

    return path

# Thu·∫≠t to√°n Steepest Ascent Hill Climbing
def steepest_ascent_hill_climbing(start, goal):
    print("\nüîç ƒêang ch·∫°y Steepest Ascent Hill Climbing...")
    current_state = start
    path = [current_state]
    visited = set()
    visited.add(tuple(map(tuple, current_state)))

    while current_state != goal:
        zero_pos = [(i, row.index(0)) for i, row in enumerate(current_state) if 0 in row][0]
        moves = get_valid_moves(zero_pos)

        # T√¨m tr·∫°ng th√°i con t·ªët nh·∫•t (c√≥ kho·∫£ng c√°ch Manhattan nh·ªè nh·∫•t)
        best_states = []
        best_heuristic = float('inf')

        for move in moves:
            new_state = swap_tiles([row[:] for row in current_state], zero_pos, move)
            state_tuple = tuple(map(tuple, new_state))
            if state_tuple not in visited:
                heuristic = manhattan_distance(new_state, goal)
                if heuristic < best_heuristic:
                    best_heuristic = heuristic
                    best_states = [new_state]
                elif heuristic == best_heuristic:
                    best_states.append(new_state)

        # N·∫øu kh√¥ng t√¨m th·∫•y tr·∫°ng th√°i con n√†o t·ªët h∆°n, d·ª´ng l·∫°i
        if not best_states:
            print("‚ùå ƒê√£ d·ª´ng l·∫°i t·∫°i c·ª±c ƒë·∫°i c·ª•c b·ªô!")
            return path

        # Ch·ªçn ng·∫´u nhi√™n m·ªôt tr·∫°ng th√°i t·ªët nh·∫•t ƒë·ªÉ ti·∫øp t·ª•c
        current_state = random.choice(best_states)
        visited.add(tuple(map(tuple, current_state)))
        path.append(current_state)

    return path

# Thu·∫≠t to√°n Stochastic Hill Climbing
def stochastic_hill_climbing(start, goal, max_iterations=10000, temperature=0.1):
    print("\nüîç ƒêang ch·∫°y Stochastic Hill Climbing...")
    current_state = start
    path = [current_state]
    visited = set()
    visited.add(tuple(map(tuple, current_state)))
    iteration = 0

    while current_state != goal and iteration < max_iterations:
        zero_pos = [(i, row.index(0)) for i, row in enumerate(current_state) if 0 in row][0]
        moves = get_valid_moves(zero_pos)

        # T·∫°o danh s√°ch c√°c tr·∫°ng th√°i con (neighbors)
        neighbors = []
        heuristics = []
        for move in moves:
            new_state = swap_tiles([row[:] for row in current_state], zero_pos, move)
            state_tuple = tuple(map(tuple, new_state))
            if state_tuple not in visited:
                neighbors.append(new_state)
                heuristics.append(manhattan_distance(new_state, goal))

        # N·∫øu kh√¥ng c√≥ tr·∫°ng th√°i con n√†o, d·ª´ng l·∫°i
        if not neighbors:
            print("‚ùå ƒê√£ d·ª´ng l·∫°i t·∫°i c·ª±c ƒë·∫°i c·ª•c b·ªô!")
            return path

        # T√≠nh x√°c su·∫•t ch·ªçn t·ª´ng tr·∫°ng th√°i con
        current_heuristic = manhattan_distance(current_state, goal)
        probabilities = []
        for h in heuristics:
            delta = h - current_heuristic  # S·ª± thay ƒë·ªïi heuristic
            if delta <= 0:  # N·∫øu tr·∫°ng th√°i con t·ªët h∆°n ho·∫∑c b·∫±ng
                prob = 1.0
            else:  # N·∫øu tr·∫°ng th√°i con t·ªá h∆°n
                prob = math.exp(-delta / temperature)  # X√°c su·∫•t ch·∫•p nh·∫≠n tr·∫°ng th√°i t·ªá h∆°n
            probabilities.append(prob)

        # Chu·∫©n h√≥a x√°c su·∫•t
        total_prob = sum(probabilities)
        if total_prob == 0:
            probabilities = [1/len(probabilities)] * len(probabilities)  # N·∫øu t·∫•t c·∫£ x√°c su·∫•t b·∫±ng 0, ch·ªçn ng·∫´u nhi√™n
        else:
            probabilities = [p/total_prob for p in probabilities]

        # Ch·ªçn ng·∫´u nhi√™n m·ªôt tr·∫°ng th√°i con d·ª±a tr√™n x√°c su·∫•t
        next_state = random.choices(neighbors, weights=probabilities, k=1)[0]

        # C·∫≠p nh·∫≠t tr·∫°ng th√°i hi·ªán t·∫°i
        current_state = next_state
        visited.add(tuple(map(tuple, current_state)))
        path.append(current_state)
        iteration += 1

    if iteration >= max_iterations:
        print("‚ùå ƒê√£ ƒë·∫°t gi·ªõi h·∫°n s·ªë l·∫ßn l·∫∑p!")
    return path

# Thu·∫≠t to√°n Simulated Annealing
def simulated_annealing(start_state, goal_state):
    print("\nüîç ƒêang ch·∫°y Simulated Annealing...")
    current_state = [row[:] for row in start_state]
    best_state = [row[:] for row in start_state]
    path = []
    best_path = []
    temperature = 1000.0
    min_temperature = 0.01
    max_iterations = 10000
    cooling_rate = 0.995
    max_cost = manhattan_distance(start_state, goal_state) + 10
    current_cost = manhattan_distance(current_state, goal_state)
    best_cost = current_cost
    step_count = 0
    start_time = time.time()
    timeout = 10

    moves_dict = {
        'up': (-1, 0),
        'down': (1, 0),
        'left': (0, -1),
        'right': (0, 1)
    }

    def find_blank(state):
        for i in range(3):
            for j in range(3):
                if state[i][j] == 0:
                    return i, j

    def is_valid(x, y):
        return 0 <= x < 3 and 0 <= y < 3

    def move_tile(state, move):
        x, y = find_blank(state)
        dx, dy = moves_dict[move]
        new_x, new_y = x + dx, y + dy
        if is_valid(new_x, new_y):
            new_state = [row[:] for row in state]
            new_state[x][y], new_state[new_x][new_y] = new_state[new_x][new_y], new_state[x][y]
            return new_state
        return state

    for iteration in range(max_iterations):
        if time.time() - start_time > timeout:
            break
        step_count += 1
        if current_state == goal_state:
            print(f"‚úÖ T√¨m th·∫•y l·ªùi gi·∫£i sau {step_count} b∆∞·ªõc.")
            return [start_state] + [apply_move(start_state, move) for move in path]

        x, y = find_blank(current_state)
        possible_moves = [move for move, (dx, dy) in moves_dict.items() if is_valid(x + dx, y + dy)]
        if not possible_moves:
            break

        move_confidences = []
        for move in possible_moves:
            new_state = move_tile(current_state, move)
            new_cost = manhattan_distance(new_state, goal_state)
            move_confidence = 1 / (1 + new_cost / max_cost) if max_cost > 0 else 0.0
            move_confidences.append((move_confidence, move, new_state))
        confidences = [conf for conf, _, _ in move_confidences]
        total_conf = sum(confidences)
        probabilities = [conf / total_conf if total_conf > 0 else 1 / len(possible_moves)
                         for conf in confidences]

        _, move, new_state = random.choices(move_confidences, weights=probabilities, k=1)[0]
        new_cost = manhattan_distance(new_state, goal_state)
        cost_diff = new_cost - current_cost

        if cost_diff <= 0 or random.random() < math.exp(-cost_diff / temperature):
            current_state = [row[:] for row in new_state]
            current_cost = new_cost
            path.append(move)
            if current_cost < best_cost:
                best_state = [row[:] for row in current_state]
                best_cost = current_cost
                best_path = path[:]

        temperature *= cooling_rate
        if temperature < min_temperature:
            break

    # reconstruct path
    if best_state == goal_state:
        print(f"‚úÖ T√¨m th·∫•y l·ªùi gi·∫£i sau {step_count} b∆∞·ªõc.")
        result_path = [start_state]
        temp_state = [row[:] for row in start_state]
        for move in best_path:
            temp_state = move_tile(temp_state, move)
            result_path.append(temp_state)
        return result_path

    print("‚ùå Kh√¥ng t√¨m th·∫•y l·ªùi gi·∫£i b·∫±ng Simulated Annealing.")
    return None

# Thu·∫≠t to√°n Beam Search
def beam_search(start, goal, beam_width=3):
    print("\nüîç ƒêang ch·∫°y Beam Search...")
    # H√†ng ƒë·ª£i ∆∞u ti√™n: (heuristic, state, path)
    queue = [(manhattan_distance(start, goal), start, [start])]
    visited = set()
    visited.add(tuple(map(tuple, start)))

    while queue:
        # L·∫•y top beam_width tr·∫°ng th√°i t·ª´ h√†ng ƒë·ª£i
        current_level = []
        for _ in range(min(beam_width, len(queue))):
            if not queue:
                break
            heuristic, state, path = heapq.heappop(queue)
            current_level.append((state, path))

        # N·∫øu kh√¥ng c√≤n tr·∫°ng th√°i n√†o ƒë·ªÉ kh√°m ph√°
        if not current_level:
            print("‚ùå Kh√¥ng t√¨m th·∫•y l·ªùi gi·∫£i!")
            return None

        # Kh√°m ph√° c√°c tr·∫°ng th√°i trong level hi·ªán t·∫°i
        next_queue = []
        for state, path in current_level:
            if state == goal:
                print(f"‚úÖ T√¨m th·∫•y gi·∫£i ph√°p v·ªõi beam width {beam_width}!")
                return path

            zero_pos = [(i, row.index(0)) for i, row in enumerate(state) if 0 in row][0]
            moves = get_valid_moves(zero_pos)

            for move in moves:
                new_state = swap_tiles([row[:] for row in state], zero_pos, move)
                state_tuple = tuple(map(tuple, new_state))
                if state_tuple not in visited:
                    visited.add(state_tuple)
                    new_path = path + [new_state]
                    heuristic = manhattan_distance(new_state, goal)
                    heapq.heappush(next_queue, (heuristic, new_state, new_path))

        # C·∫≠p nh·∫≠t h√†ng ƒë·ª£i v·ªõi top beam_width tr·∫°ng th√°i t·ª´ next_queue
        queue = []
        for _ in range(min(beam_width, len(next_queue))):
            if not next_queue:
                break
            heapq.heappush(queue, heapq.heappop(next_queue))

    print("‚ùå Kh√¥ng t√¨m th·∫•y l·ªùi gi·∫£i!")
    return None

'''def and_or_graph_search(start_state, goal_state):
    stack = [(start_state, [])]
    visited = set()

    while stack:
        current_state, path = stack.pop()
        state_tuple = tuple(map(tuple, current_state))
        if state_tuple in visited:
            continue
        visited.add(state_tuple)

        if current_state == goal_state:
            return path

        for neighbor in reversed(generate_neighbors(current_state)):
            if tuple(map(tuple, neighbor)) not in visited:
                stack.append((neighbor, path + [neighbor]))

    return None'''

# H√†m t·∫°o tr·∫°ng th√°i ti·∫øp theo t·ª´ m·ªôt n∆∞·ªõc ƒëi
def apply_move(state, move):
    zero_pos = [(i, row.index(0)) for i, row in enumerate(state) if 0 in row][0]
    new_state = swap_tiles([row[:] for row in state], zero_pos, move)
    return new_state

# H√†m t·∫°o m·ªôt chu·ªói n∆∞·ªõc ƒëi ng·∫´u nhi√™n
def generate_random_moves(length):
    moves = []
    for _ in range(length):
        # M·ªói n∆∞·ªõc ƒëi l√† m·ªôt h∆∞·ªõng: 0 (l√™n), 1 (xu·ªëng), 2 (tr√°i), 3 (ph·∫£i)
        move = random.randint(0, 3)
        moves.append(move)
    return moves

# H√†m √°p d·ª•ng chu·ªói n∆∞·ªõc ƒëi v√†o tr·∫°ng th√°i ban ƒë·∫ßu
def apply_moves_to_state(start_state, moves):
    state = [row[:] for row in start_state]
    zero_pos = [(i, row.index(0)) for i, row in enumerate(state) if 0 in row][0]
    for move in moves:
        # Chuy·ªÉn ƒë·ªïi move (0, 1, 2, 3) th√†nh t·ªça ƒë·ªô
        x, y = zero_pos
        if move == 0 and x > 0:  # L√™n
            new_pos = (x - 1, y)
        elif move == 1 and x < 2:  # Xu·ªëng
            new_pos = (x + 1, y)
        elif move == 2 and y > 0:  # Tr√°i
            new_pos = (x, y - 1)
        elif move == 3 and y < 2:  # Ph·∫£i
            new_pos = (x, y + 1)
        else:
            continue  # B·ªè qua n∆∞·ªõc ƒëi kh√¥ng h·ª£p l·ªá
        state = swap_tiles(state, zero_pos, new_pos)
        zero_pos = new_pos
    return state

# Thu·∫≠t to√°n Genetic Algorithm
def genetic_algorithm(start, goal, population_size=200, max_generations=2000, max_moves=70, mutation_rate=0.2):
    print("\nüîç ƒêang ch·∫°y Genetic Algorithm (n√¢ng c·∫•p)...")

    def fitness_function(state, moves):
        # H√†m ƒë√°nh gi√°: c√†ng g·∫ßn goal c√†ng t·ªët, √≠t b∆∞·ªõc c√†ng t·ªët
        return manhattan_distance(state, goal) + 0.1 * len(moves)

    # Kh·ªüi t·∫°o qu·∫ßn th·ªÉ: m·ªói c√° th·ªÉ l√† chu·ªói b∆∞·ªõc ƒëi ng·∫´u nhi√™n
    population = [generate_random_moves(random.randint(30, max_moves)) for _ in range(population_size)]

    for generation in range(max_generations):
        fitness_scores = []
        for individual in population:
            final_state = apply_moves_to_state(start, individual)
            fitness = fitness_function(final_state, individual)
            fitness_scores.append((fitness, individual))

            if final_state == goal:
                print(f"‚úÖ T√¨m th·∫•y gi·∫£i ph√°p ·ªü th·∫ø h·ªá {generation}!")

                # D·ª±ng l·∫°i path t·ª´ individual
                path = [start]
                current_state = [row[:] for row in start]
                for move in individual:
                    zero_pos = [(i, row.index(0)) for i, row in enumerate(current_state) if 0 in row][0]
                    x, y = zero_pos
                    if move == 0 and x > 0:
                        new_pos = (x - 1, y)
                    elif move == 1 and x < 2:
                        new_pos = (x + 1, y)
                    elif move == 2 and y > 0:
                        new_pos = (x, y - 1)
                    elif move == 3 and y < 2:
                        new_pos = (x, y + 1)
                    else:
                        continue
                    current_state = swap_tiles([row[:] for row in current_state], zero_pos, new_pos)
                    path.append(current_state)
                return path

        # Ch·ªçn 30% c√° th·ªÉ t·ªët nh·∫•t
        fitness_scores.sort(key=lambda x: x[0])
        elite_count = population_size // 3
        selected = [individual for _, individual in fitness_scores[:elite_count]]

        # T·∫°o th·∫ø h·ªá m·ªõi
        new_population = selected[:]

        while len(new_population) < population_size:
            parent1, parent2 = random.sample(selected, 2)
            crossover_point = random.randint(1, min(len(parent1), len(parent2)) - 1)
            child = parent1[:crossover_point] + parent2[crossover_point:]

            # ƒê·ªôt bi·∫øn
            if random.random() < mutation_rate:
                mutation_point = random.randint(0, len(child) - 1)
                child[mutation_point] = random.randint(0, 3)

            # C·∫Øt ng·∫Øn n·∫øu qu√° d√†i
            if len(child) > max_moves:
                child = child[:max_moves]
            new_population.append(child)

        population = new_population

        # In th√¥ng tin debug
        if generation % 100 == 0:
            best_fitness = fitness_scores[0][0]
            print(f"üìä Th·∫ø h·ªá {generation} - Fitness t·ªët nh·∫•t: {best_fitness:.2f}")

    print("‚ùå Kh√¥ng t√¨m th·∫•y l·ªùi gi·∫£i sau s·ªë th·∫ø h·ªá t·ªëi ƒëa.")
    return None

def bfs_belief(initial_beliefs, goal_beliefs):
    print("\nüîç ƒêang ch·∫°y BFS tr√™n Belief States...")

    def apply_action_to_belief(belief_state, action):
        next_belief = set()
        for state in belief_state:
            state_list = [list(row) for row in state]
            zero_pos = [(i, row.index(0)) for i, row in enumerate(state_list) if 0 in row][0]
            x, y = zero_pos
            dx, dy = action
            nx, ny = x + dx, y + dy

            if 0 <= nx < 3 and 0 <= ny < 3:
                new_state = [row[:] for row in state_list]
                new_state[x][y], new_state[nx][ny] = new_state[nx][ny], new_state[x][y]
                next_belief.add(tuple(map(tuple, new_state)))
            else:
                # Kh√¥ng di chuy·ªÉn ƒë∆∞·ª£c th√¨ gi·ªØ nguy√™n
                next_belief.add(state)
        return next_belief

    actions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # up, down, left, right
    action_names = ["‚Üë", "‚Üì", "‚Üê", "‚Üí"]

    # Bi·∫øn tr·∫°ng th√°i ban ƒë·∫ßu v√† goal th√†nh d·∫°ng hashable
    initial_belief = set(tuple(map(tuple, s)) for s in initial_beliefs)
    goal_set = set(tuple(map(tuple, g)) for g in goal_beliefs)

    visited = set()
    visited.add(frozenset(initial_belief))
    queue = deque([(initial_belief, [])])

    MAX_DEPTH = 50
    MAX_STEPS = 1_000_000
    step_counter = 0
    max_depth_seen = 0

    while queue:
        belief_state, path = queue.popleft()
        step_counter += 1
        max_depth_seen = max(max_depth_seen, len(path))

        if step_counter % 10000 == 0:
            print(f"üîÑ BFS b∆∞·ªõc {step_counter:,} ‚Äì belief size: {len(belief_state)} ‚Äì depth: {len(path)}")

        # Ki·ªÉm tra ƒëi·ªÅu ki·ªán d·ª´ng
        if all(s in goal_set for s in belief_state):
            print(f"‚úÖ T√¨m th·∫•y k·∫ø ho·∫°ch sau {step_counter:,} b∆∞·ªõc duy·ªát ‚Äì ƒë·ªô s√¢u {len(path)}.")
            return path

        if len(path) >= MAX_DEPTH:
            continue

        for i, action in enumerate(actions):
            next_belief = apply_action_to_belief(belief_state, action)
            frozen_next = frozenset(next_belief)

            if frozen_next == frozenset(belief_state):
                # N·∫øu kh√¥ng c√≥ g√¨ thay ƒë·ªïi, b·ªè qua
                continue

            if frozen_next not in visited:
                visited.add(frozen_next)
                queue.append((next_belief, path + [action_names[i]]))

        if step_counter >= MAX_STEPS:
            print(f"‚õî ƒê·∫°t gi·ªõi h·∫°n s·ªë b∆∞·ªõc: {MAX_STEPS:,}. D·ª´ng BFS.")
            return None

    print(f"‚ùå Kh√¥ng t√¨m th·∫•y k·∫ø ho·∫°ch sau {step_counter:,} b∆∞·ªõc duy·ªát. Chi·ªÅu s√¢u cao nh·∫•t: {max_depth_seen}")
    return None

# H√†m t√≠nh kho·∫£ng c√°ch Manhattan
def manhattan_distance(state, goal):
    distance = 0
    print("State:", state)
    for i in range(3):
        for j in range(3):
            value = state[i][j]
            if value != 0:  # Kh√¥ng t√≠nh √¥ tr·ªëng
                goal_x, goal_y = [(x, y) for x in range(3) for y in range(3) if goal[x][y] == value][0]
                distance += abs(i - goal_x) + abs(j - goal_y)
    return distance

# H√†m l·∫•y c√°c n∆∞·ªõc ƒëi h·ª£p l·ªá
def get_valid_moves(zero_pos):
    x, y = zero_pos
    moves = []
    if x > 0: moves.append((x - 1, y))  # L√™n tr√™n
    if x < 2: moves.append((x + 1, y))  # Xu·ªëng d∆∞·ªõi
    if y > 0: moves.append((x, y - 1))  # Sang tr√°i
    if y < 2: moves.append((x, y + 1))  # Sang ph·∫£i
    return moves

# H√†m ƒë·ªïi ch·ªó √¥ tr·ªëng v·ªõi √¥ b√™n c·∫°nh
def swap_tiles(state, zero_pos, move):
    x1, y1 = zero_pos
    x2, y2 = move
    state[x1][y1], state[x2][y2] = state[x2][y2], state[x1][y1]
    return state

# L·ªõp giao di·ªán
class PuzzleApp:
    def __init__(self, root, initial_state, goal_state):
        self.root = root
        self.root.title("Gi·∫£i b√†i to√°n 8-Puzzle")
        self.initial_state = initial_state
        self.goal_state = goal_state
        self.steps = []
        self.step_index = 0
        self.run_history = []  # l∆∞u l·ªãch s·ª≠ ch·∫°y

        main_frame = tk.Frame(root, padx=10, pady=10)
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Board b√™n tr√°i
        board_frame = tk.LabelFrame(main_frame, text="B·∫£ng 8-Puzzle", font=("Arial", 14))
        board_frame.grid(row=0, column=0, padx=10, pady=5)

        self.grid_buttons = [[tk.Button(board_frame, text=str(initial_state[i][j]) if initial_state[i][j] != 0 else "",
                                        font=('Arial', 24), width=4, height=2, bg="#ADD8E6")
                              for j in range(3)] for i in range(3)]

        for i in range(3):
            for j in range(3):
                self.grid_buttons[i][j].grid(row=i, column=j, padx=5, pady=5)

        # Text log b√™n ph·∫£i (c√≥ thanh cu·ªôn)
        log_frame = tk.LabelFrame(main_frame, text="K·∫øt qu·∫£ gi·∫£i", font=("Arial", 14))
        log_frame.grid(row=0, column=1, padx=10, pady=5, sticky="n")

        self.output_text = tk.Text(log_frame, width=50, height=20, font=("Courier", 10), wrap=tk.WORD)
        scrollbar = tk.Scrollbar(log_frame, command=self.output_text.yview)
        self.output_text.config(yscrollcommand=scrollbar.set)
        self.output_text.grid(row=0, column=0)
        scrollbar.grid(row=0, column=1, sticky="ns")

        # C·∫•u h√¨nh tag ƒë·ªÉ th√™m m√†u
        self.output_text.tag_config("time", foreground="blue")
        self.output_text.tag_config("stepcount", foreground="purple")
        self.output_text.tag_config("header", foreground="black", font=("Courier", 10, "bold"))
        self.output_text.tag_config("step", foreground="green")
        self.output_text.tag_config("error", foreground="red")

        # Khung ch·ªçn thu·∫≠t to√°n ph√≠a d∆∞·ªõi
        algo_frame = tk.LabelFrame(main_frame, text="Ch·ªçn thu·∫≠t to√°n", font=("Arial", 14))
        algo_frame.grid(row=1, column=0, columnspan=2, pady=10, sticky="ew")

        buttons = [
            ("BFS", self.solve_bfs),
            ("DFS", self.solve_dfs),
            ("UCS", self.solve_ucs),
            ("IDS", self.solve_ids),
            ("Greedy", self.solve_greedy),
            ("A*", self.solve_a_star),
            ("IDA*", self.solve_ida_star),
            ("Simple HC", self.solve_simple_hill_climbing),
            ("Steepest HC", self.solve_steepest_ascent_hill_climbing),
            ("Stochastic HC", self.solve_stochastic_hill_climbing),
            ("Simulated Annealing", self.solve_simulated_annealing),
            ("Beam Search", self.solve_beam_search),
            #("And/Or Graph", self.solve_and_or_graph),
            ("Genetic", self.solve_genetic),
            ("Belief BFS", self.solve_belief_bfs),
        ]

        for i, (label, func) in enumerate(buttons):
            tk.Button(algo_frame, text=label, width=15, command=func).grid(row=i//3, column=i%3, padx=5, pady=5)

        # Label tr·∫°ng th√°i cu·ªëi c√πng + n√∫t l·ªãch s·ª≠
        self.status_label = tk.Label(root, text="Ch·ªçn thu·∫≠t to√°n ƒë·ªÉ gi·∫£i", font=("Arial", 12), fg="blue")
        self.status_label.pack(pady=5)

        tk.Button(root, text="üß† Belief States", command=self.open_belief_state_window).pack(pady=5)
        tk.Button(root, text="üóÇÔ∏è L·ªãch s·ª≠ ch·∫°y", command=self.show_history).pack(pady=5)

    def log(self, msg, tag=None):
        self.output_text.insert(tk.END, msg + "\n", tag)
        self.output_text.see(tk.END)

    def show_next_step(self):
        if self.step_index < len(self.steps):
            self.update_grid(self.steps[self.step_index])
            self.step_index += 1
            self.root.after(400, self.show_next_step)
        else:
            self.status_label.config(text="\u2714\ufe0f ƒê√£ gi·∫£i xong!", fg="green")

    def update_grid(self, state):
        for i in range(3):
            for j in range(3):
                self.grid_buttons[i][j].config(text=str(state[i][j]) if state[i][j] != 0 else "")

    def print_solution(self, steps, runtime):
        self.log(f"‚è±Ô∏è Th·ªùi gian ch·∫°y: {runtime:.4f} gi√¢y", "time")
        self.log(f"üî¢ T·ªïng s·ªë b∆∞·ªõc: {len(steps)}", "stepcount")
        self.log("\nüîπ C√°c b∆∞·ªõc gi·∫£i b√†i to√°n 8-Puzzle:", "header")
        for i, state in enumerate(steps):
            self.log(f"\nüü¢ B∆∞·ªõc {i+1}:", "step")
            for row in state:
                self.log(" ".join(str(n) if n != 0 else "‚óª" for n in row))

    def run_solver(self, solver_func, name):
        self.status_label.config(text=f"ƒêang ch·∫°y {name}...", fg="orange")
        self.output_text.delete(1.0, tk.END)
        start_time = time.time()
        self.steps = solver_func(self.initial_state, self.goal_state)
        runtime = time.time() - start_time
        if self.steps:
            self.step_index = 0
            self.print_solution(self.steps, runtime)
            self.show_next_step()
            self.run_history.append({
                "index": len(self.run_history) + 1,
                "algorithm": name,
                "time": f"{runtime:.4f}s",
                "steps": len(self.steps)
            })
        else:
            self.status_label.config(text="Kh√¥ng t√¨m th·∫•y l·ªùi gi·∫£i!", fg="red")
            self.log("üõë Kh√¥ng t√¨m th·∫•y l·ªùi gi·∫£i.", "error")

    def show_history(self):
        history_window = tk.Toplevel(self.root)
        history_window.title("üóÇÔ∏è L·ªãch s·ª≠ ch·∫°y")
        history_window.minsize(width=600, height=300)

        tree = ttk.Treeview(history_window, columns=("Index", "Algo", "Time", "Steps"), show="headings")
        tree.column("Index", anchor="center", width=50)
        tree.column("Algo", anchor="center", width=180)
        tree.column("Time", anchor="center", width=100)
        tree.column("Steps", anchor="center", width=80)

        tree.heading("Index", text="L·∫ßn")
        tree.heading("Algo", text="Thu·∫≠t to√°n")
        tree.heading("Time", text="Th·ªùi gian")
        tree.heading("Steps", text="S·ªë b∆∞·ªõc")

        for entry in self.run_history:
            tree.insert("", "end", values=(entry["index"], entry["algorithm"], entry["time"], entry["steps"]))

        tree.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)

    # C√°c h√†m t∆∞∆°ng ·ª©ng m·ªói thu·∫≠t to√°n
    def solve_bfs(self): self.run_solver(bfs, "BFS")
    def solve_dfs(self): self.run_solver(dfs, "DFS")
    def solve_ucs(self): self.run_solver(ucs, "UCS")
    def solve_ids(self): self.run_solver(ids, "IDS")
    def solve_greedy(self): self.run_solver(greedy, "Greedy")
    def solve_a_star(self): self.run_solver(a_star, "A*")
    def solve_ida_star(self): self.run_solver(ida_star, "IDA*")
    def solve_simple_hill_climbing(self): self.run_solver(simple_hill_climbing, "Simple Hill Climbing")
    def solve_steepest_ascent_hill_climbing(self): self.run_solver(steepest_ascent_hill_climbing, "Steepest Ascent Hill Climbing")
    def solve_stochastic_hill_climbing(self): self.run_solver(stochastic_hill_climbing, "Stochastic Hill Climbing")
    def solve_simulated_annealing(self): self.run_solver(simulated_annealing, "Simulated Annealing")
    def solve_beam_search(self): self.run_solver(beam_search, "Beam Search")
    #def solve_and_or_graph(self): self.run_solver(and_or_graph_search, "And/Or Graph Searching")
    def solve_genetic(self): self.run_solver(genetic_algorithm, "Genetic Algorithm")

    def solve_belief_bfs(self):
        if not hasattr(self, 'initial_beliefs') or not hasattr(self, 'goal_beliefs'):
            messagebox.showerror("‚ùå L·ªói", "Ch∆∞a c√≥ d·ªØ li·ªáu belief states. Vui l√≤ng nh·∫≠p tr∆∞·ªõc.")
            return

        self.output_text.delete(1.0, tk.END)
        self.log("üöÄ ƒêang ch·∫°y BFS tr√™n belief states...", "header")
        self.status_label.config(text="ƒêang ch·∫°y BFS tr√™n belief states...", fg="orange")

        def run_belief_bfs_in_thread():
            start_time = time.time()
            plan = bfs_belief(self.initial_beliefs, self.goal_beliefs)
            end_time = time.time()
            self.root.after(0, lambda: self.handle_belief_bfs_result(plan, start_time, end_time))

        threading.Thread(target=run_belief_bfs_in_thread).start()

    def handle_belief_bfs_result(self, plan, start_time, end_time):
        if not plan:
            self.log("‚ùå Kh√¥ng t√¨m th·∫•y k·∫ø ho·∫°ch n√†o.", "error")
            self.status_label.config(text="Kh√¥ng t√¨m th·∫•y k·∫ø ho·∫°ch belief.", fg="red")
            return

        self.log(f"‚è±Ô∏è Th·ªùi gian ch·∫°y: {end_time - start_time:.4f} gi√¢y", "info")
        self.log(f"üî¢ T·ªïng s·ªë b∆∞·ªõc: {len(plan)}", "info")

        self.log("\nüéØ Goal Belief States:", "info")
        for g in self.goal_beliefs:
            self.log("‚îÄ‚îÄ‚îÄ")
            for row in g:
                self.log(" ".join("‚óª" if n == 0 else str(n) for n in row))

        belief_state = set(tuple(map(tuple, s)) for s in self.initial_beliefs)

        self.log("\nüîπ C√°c b∆∞·ªõc gi·∫£i b√†i to√°n 8-Puzzle tr√™n belief state:\n", "info")

        actions = {
            "‚Üë": (-1, 0),
            "‚Üì": (1, 0),
            "‚Üê": (0, -1),
            "‚Üí": (0, 1)
        }

        def apply_action(state, action):
            state_list = [list(row) for row in state]
            zero_pos = [(i, row.index(0)) for i, row in enumerate(state_list) if 0 in row][0]
            x, y = zero_pos
            dx, dy = action
            nx, ny = x + dx, y + dy
            if 0 <= nx < 3 and 0 <= ny < 3:
                new_state = [row[:] for row in state_list]
                new_state[x][y], new_state[nx][ny] = new_state[nx][ny], new_state[x][y]
                return tuple(map(tuple, new_state))
            return None

        for step_idx, move in enumerate(plan):
            self.log(f"\nüü¢ B∆∞·ªõc {step_idx + 1}: {move}", "step")
            self.log(f"Belief state hi·ªán t·∫°i ({len(belief_state)} tr·∫°ng th√°i):", "info")
            for state in sorted(belief_state):
                self.log("‚îÄ‚îÄ‚îÄ")
                for row in state:
                    self.log(" ".join("‚óª" if n == 0 else str(n) for n in row))
            self.log("")

            new_belief = set()
            for state in belief_state:
                result = apply_action(state, actions[move])
                if result:
                    new_belief.add(result)
                else:
                    new_belief.add(state)
            belief_state = new_belief

        self.status_label.config(text="‚úÖ ƒê√£ t√¨m ƒë∆∞·ª£c k·∫ø ho·∫°ch belief!", fg="green")

 
    def open_belief_state_window(self):
        window = tk.Toplevel(self.root)
        window.title("Nh·∫≠p tr·∫°ng th√°i ni·ªÅm tin (Belief States)")
        window.geometry("800x600")

        tk.Label(window, text="S·ªë tr·∫°ng th√°i kh·ªüi ƒë·∫ßu:", font=("Arial", 12)).grid(row=0, column=0, padx=5, pady=5, sticky="w")
        initial_count_var = tk.IntVar()
        tk.Entry(window, textvariable=initial_count_var, width=5).grid(row=0, column=1)

        tk.Label(window, text="S·ªë tr·∫°ng th√°i ƒë√≠ch:", font=("Arial", 12)).grid(row=0, column=2, padx=5, pady=5, sticky="w")
        goal_count_var = tk.IntVar()
        tk.Entry(window, textvariable=goal_count_var, width=5).grid(row=0, column=3)

        input_frame = tk.Frame(window)
        input_frame.grid(row=2, column=0, columnspan=4, pady=10)

        boards = {"initial": [], "goal": []}

        def create_input_tables():
            for widget in input_frame.winfo_children():
                widget.destroy()

            def create_board(title, index, board_type):
                frame = tk.LabelFrame(input_frame, text=f"{title} #{index+1}", padx=5, pady=5)
                frame.grid(row=index // 2, column=index % 2 + (0 if board_type == "initial" else 2), padx=5, pady=5)
                cells = []
                for i in range(3):
                    row = []
                    for j in range(3):
                        entry = tk.Entry(frame, width=3, font=("Arial", 14), justify="center")
                        entry.grid(row=i, column=j, padx=2, pady=2)
                        row.append(entry)
                    cells.append(row)
                boards[board_type].append(cells)

            for i in range(initial_count_var.get()):
                create_board("Initial State", i, "initial")
            for i in range(goal_count_var.get()):
                create_board("Goal State", i, "goal")

        def read_belief_states():
            def read_board(cells):
                board = []
                for row in cells:
                    board_row = []
                    for entry in row:
                        try:
                            val = int(entry.get())
                            if val < 0 or val > 8:
                                raise ValueError
                        except:
                            messagebox.showerror("L·ªói", "Gi√° tr·ªã kh√¥ng h·ª£p l·ªá! Vui l√≤ng nh·∫≠p s·ªë t·ª´ 0 ƒë·∫øn 8.")
                            return None
                        board_row.append(val)
                    board.append(board_row)
                return board

            initial_beliefs = []
            for cells in boards["initial"]:
                board = read_board(cells)
                if board is None:
                    return
                initial_beliefs.append(board)

            goal_beliefs = []
            for cells in boards["goal"]:
                board = read_board(cells)
                if board is None:
                    return
                goal_beliefs.append(board)

            # ‚úÖ L∆∞u v√†o thu·ªôc t√≠nh c·ªßa l·ªõp ƒë·ªÉ d√πng sau
            self.initial_beliefs = initial_beliefs
            self.goal_beliefs = goal_beliefs

            # In ki·ªÉm tra
            print("üîπ Initial Belief States:")
            for b in initial_beliefs:
                for row in b:
                    print(row)
                print()

            print("üîπ Goal Belief States:")
            for b in goal_beliefs:
                for row in b:
                    print(row)
                print()

            messagebox.showinfo("‚úÖ Th√†nh c√¥ng", f"ƒê√£ l∆∞u {len(initial_beliefs)} initial v√† {len(goal_beliefs)} goal states.")

        tk.Button(window, text="Kh·ªüi t·∫°o b·∫£ng nh·∫≠p", command=create_input_tables).grid(row=1, column=0, columnspan=4, pady=5)
        # Placeholder button ƒë·ªÉ sau n√†y ch·∫°y thu·∫≠t to√°n
        tk.Button(window, text="ƒê·ªçc Belief States", command=read_belief_states).grid(row=99, column=0, columnspan=4, pady=10)

# Ch·∫°y ch∆∞∆°ng tr√¨nh
if __name__ == "__main__":
    initial_state = [[2, 6, 5], [0, 8, 7], [4, 3, 1]]  # 0 l√† √¥ tr·ªëng
    goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]

    root = tk.Tk()
    app = PuzzleApp(root, initial_state, goal_state)
    root.mainloop()
